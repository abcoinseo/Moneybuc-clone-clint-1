<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EarnFlux</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">
    <link rel="stylesheet" href="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.css">
    <style>
        :root {
            --primary-color: #6200EE; /* Deep Purple */
            --secondary-color: #03DAC6; /* Teal */
            --background-color: #f0f2f5;
            --text-color: #333;
            --card-background: #fff;
            --button-text-color: #fff;
            --footer-background: #fff;
            --dark-background: #121212;
            --dark-text-color: #e0e0e0;
            --dark-card-background: #1e1e1e;
            --dark-footer-background: #1e1e1e;
            --accent-color: #FFC107; /* Amber */
        }
        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: 'Roboto', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .header {
            background-color: var(--primary-color);
            color: var(--button-text-color);
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        .header .material-icons {
            cursor: pointer;
        }
        .container {
            flex: 1;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            padding-bottom: 80px; /* Space for the bottom nav */
        }
        .card {
            background-color: var(--card-background);
            border-radius: 12px;
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        h2, h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-weight: 500;
        }
        .input-field label {
            color: var(--primary-color);
        }
        .input-field input[type=text]:not(.browser-default):focus:not([readonly]),
        .input-field input[type=number]:not(.browser-default):focus:not([readonly]),
        .input-field textarea:focus:not([readonly]) {
            border-bottom: 1px solid var(--primary-color);
            box-shadow: 0 1px 0 0 var(--primary-color);
        }
        .btn {
            background-color: var(--primary-color);
            color: var(--button-text-color);
            margin-top: 10px;
            border-radius: 8px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            text-transform: none;
            letter-spacing: 0;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(98, 0, 238, 0.2);
        }
        .btn:hover {
            background-color: #4a00ba; /* Darker Purple */
            transform: translateY(-2px);
        }
        .btn-large {
            padding: 0 25px;
        }
        .secondary-btn {
            background-color: var(--secondary-color);
            box-shadow: 0 4px 6px rgba(3, 205, 179, 0.2);
        }
        .secondary-btn:hover {
            background-color: #028879;
        }
        .accent-btn {
            background-color: var(--accent-color);
            color: #333 !important;
            box-shadow: 0 4px 6px rgba(255, 193, 7, 0.2);
        }
        .accent-btn:hover {
            background-color: #e0a800;
        }
        .task-item, .profile-section, .lucky-code-section, .referral-section, .ads-section, .withdraw-section, .daily-check-in-section {
            background-color: var(--card-background);
            border-radius: 12px;
            margin-bottom: 15px;
            padding: 20px;
            transition: all 0.3s ease;
            border: 1px solid rgba(0,0,0,0.05);
        }
        .task-item h3, .profile-section h3, .lucky-code-section h3, .referral-section h3, .ads-section h3, .withdraw-section h3, .daily-check-in-section h3 {
            margin-top: 0;
        }
        .task-list-item {
            border-bottom: 1px solid #eee;
            padding-bottom: 15px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .task-list-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .task-details {
            flex-grow: 1;
            margin-right: 15px;
        }
        .task-details p {
            margin: 5px 0;
            font-size: 0.9em;
            color: #666;
        }
        .task-details strong {
            font-size: 1.1em;
            color: var(--text-color);
        }
        .task-details small {
            font-size: 0.8em;
            color: #999;
        }
        .start-task-btn {
            background-color: var(--secondary-color);
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .start-task-btn:hover {
            background-color: #028879;
        }
        .start-task-btn i {
            vertical-align: middle;
            margin-right: 5px;
        }
        .progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 10px;
            height: 20px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 1s ease-in-out;
            border-radius: 5px;
        }
        .timer {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--primary-color);
            margin-top: 10px;
        }
        .completed-tasks-list {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .completed-task-item {
            font-size: 0.9em;
            color: #4CAF50; /* Green for completed */
            margin-bottom: 5px;
        }
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--footer-background);
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            z-index: 1001;
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
        }
        .bottom-nav .nav-item {
            text-align: center;
            color: #757575;
            cursor: pointer;
            padding: 5px 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: color 0.3s ease;
        }
        .bottom-nav .nav-item.active {
            color: var(--primary-color);
        }
        .bottom-nav .nav-item i {
            font-size: 28px;
            margin-bottom: 5px;
        }
        .bottom-nav .nav-item span {
            font-size: 0.8em;
        }
        .profile-details {
            text-align: center;
        }
        .profile-picture {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 15px;
            border: 3px solid var(--primary-color);
        }
        .refer-link-card {
            text-align: center;
        }
        .refer-link-card input {
            width: 80%;
            text-align: center;
            margin: 10px auto;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background-color: var(--background-color);
        }
        .referral-list-item {
            font-size: 0.9em;
            margin-bottom: 5px;
            color: #555;
        }
        .withdraw-input {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .withdraw-input input {
            flex-grow: 1;
        }
        .withdraw-input .ton-icon {
            width: 24px;
            height: 24px;
            vertical-align: middle;
        }
        .balance-display {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--primary-color);
            margin: 10px 0;
        }
        .point-unit {
            font-size: 0.8em;
            color: #757575;
            margin-left: 5px;
        }
        /* Dark Theme */
        .dark-theme {
            --background-color: var(--dark-background);
            --text-color: var(--dark-text-color);
            --card-background: var(--dark-card-background);
            --footer-background: var(--dark-footer-background);
            --primary-color: #BB86FC; /* Lighter Purple for dark mode */
            --secondary-color: #03DAC6; /* Teal */
            --accent-color: #FFAB40; /* Lighter Amber */
        }
        .dark-theme .header {
            background-color: var(--primary-color);
        }
        .dark-theme .input-field label {
            color: var(--primary-color);
        }
        .dark-theme .input-field input[type=text]:not(.browser-default):focus:not([readonly]),
        .dark-theme .input-field input[type=number]:not(.browser-default):focus:not([readonly]),
        .dark-theme .input-field textarea:focus:not([readonly]) {
            border-bottom: 1px solid var(--primary-color);
        }
        .dark-theme .btn {
            background-color: var(--primary-color);
            box-shadow: 0 4px 6px rgba(187, 134, 252, 0.2);
        }
        .dark-theme .btn:hover {
            background-color: #9b4dcf;
        }
        .dark-theme .secondary-btn {
            background-color: var(--secondary-color);
            box-shadow: 0 4px 6px rgba(3, 205, 179, 0.2);
        }
        .dark-theme .secondary-btn:hover {
            background-color: #028879;
        }
        .dark-theme .accent-btn {
            background-color: var(--accent-color);
            color: #333 !important;
            box-shadow: 0 4px 6px rgba(255, 171, 64, 0.2);
        }
        .dark-theme .accent-btn:hover {
            background-color: #e69c32;
        }
        .dark-theme .task-item,
        .dark-theme .profile-section,
        .dark-theme .lucky-code-section,
        .dark-theme .referral-section,
        .dark-theme .ads-section,
        .dark-theme .withdraw-section,
        .dark-theme .daily-check-in-section {
            background-color: var(--dark-card-background);
            border-color: rgba(255, 255, 255, 0.05);
        }
        .dark-theme .task-list-item {
            border-bottom-color: #424242;
        }
        .dark-theme .task-details p {
            color: #bdbdbd;
        }
        .dark-theme .progress-bar {
            background-color: var(--primary-color);
        }
        .dark-theme .timer {
            color: var(--primary-color);
        }
        .dark-theme .completed-task-item {
            color: #81C784; /* Lighter Green */
        }
        .dark-theme .bottom-nav {
            background-color: var(--dark-footer-background);
            box-shadow: 0 -2px 10px rgba(0,0,0,0.3);
        }
        .dark-theme .bottom-nav .nav-item {
            color: #9e9e9e;
        }
        .dark-theme .bottom-nav .nav-item.active {
            color: var(--primary-color);
        }
        .dark-theme .refer-link-card input {
            background-color: var(--dark-card-background);
            border-color: #424242;
        }
        .dark-theme .balance-display {
            color: var(--primary-color);
        }
        .dark-theme .point-unit {
            color: #bdbdbd;
        }
        /* TON Connect Specific Styles */
        #ton-connect {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 15px;
        }
        .tonconnect-ui-modal__container, .tonconnect-ui-modal__content, .tonconnect-ui-modal__header, .tonconnect-ui-modal__body {
            background-color: var(--card-background) !important;
            color: var(--text-color) !important;
        }
        .tonconnect-ui-modal__button {
            background-color: var(--primary-color) !important;
        }
        .tonconnect-ui-modal__button:hover {
            background-color: #4a00ba !important;
        }
        /* Spin Wheel */
        .spin-wheel-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }
        #spinWheel {
            width: 250px;
            height: 250px;
            border-radius: 50%;
            border: 8px solid var(--primary-color);
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s ease;
            margin-bottom: 20px;
            background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 50%);
        }
        #spinWheel.spinning {
            animation: spin 5s forwards;
        }
        .spin-segment {
            position: absolute;
            top: 0;
            left: 50%;
            width: 50%;
            height: 50%;
            transform-origin: 0% 100%;
            clip-path: polygon(0% 0%, 100% 0%, 50% 100%);
            background-color: var(--secondary-color);
            color: white;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding-top: 10px;
            font-weight: bold;
        }
        .spin-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -100%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 30px solid var(--primary-color);
            z-index: 10;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(3600deg); } /* 10 full rotations */
        }
        .spin-result {
            font-size: 1.3em;
            font-weight: bold;
            color: var(--accent-color);
            margin-top: 10px;
        }
        /* Ads Card */
        .ad-placeholder {
            width: 100%;
            min-height: 250px;
            background-color: #e0e0e0;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.2em;
            color: #757575;
            margin-bottom: 15px;
        }
        .dark-theme .ad-placeholder {
            background-color: #424242;
            color: #bdbdbd;
        }

    </style>
</head>
<body>

    <div class="header">
        <i class="material-icons menu-icon">menu</i>
        <span>EarnFlux</span>
        <i class="material-icons theme-toggle" id="theme-toggle">brightness_medium</i>
    </div>

    <ul id="slide-out" class="sidenav">
        <li><a class="subheader">Navigation</a></li>
        <li><div class="divider"></div></li>
        <li><a href="#home-section"><i class="material-icons">home</i> Home</a></li>
        <li><a href="#tasks-section"><i class="material-icons">list_alt</i> Tasks</a></li>
        <li><a href="#spin-section"><i class="material-icons">casino</i> Spin Wheel</a></li>
        <li><a href="#lucky-code-section"><i class="material-icons">redeem</i> Lucky Code</a></li>
        <li><a href="#ads-section"><i class="material-icons">ads_click</i> Ads</a></li>
        <li><a href="#referral-section"><i class="material-icons">group_add</i> Referrals</a></li>
        <li><a href="#profile-section"><i class="material-icons">account_circle</i> Profile</a></li>
        <li><div class="divider"></div></li>
        <li><a href="#logout">Logout</a></li>
    </ul>

    <div class="container">
        <section id="home-section" class="card">
            <h3>Welcome Back!</h3>
            <div class="profile-details">
                <img id="user-profile-pic" src="" alt="User Profile" class="profile-picture">
                <h4 id="user-name"></h4>
                <p>Telegram ID: <span id="user-telegram-id"></span></p>
            </div>
            <div class="balance-display">
                Balance: <span id="user-balance">0</span> <span class="point-unit">Points</span>
            </div>
            <div class="daily-check-in-section card">
                <h4>Daily Check-in</h4>
                <p>Check in daily to claim your reward!</p>
                <button class="btn waves-effect waves-light accent-btn" id="daily-check-in-btn">Claim Reward</button>
                <p id="daily-check-in-message" style="color: green; margin-top: 10px; display: none;">Reward claimed!</p>
            </div>
            <div class="ton-connect-section card">
                <h4>Wallet Connection</h4>
                <p>Connect your TON wallet to withdraw rewards.</p>
                <div id="ton-connect"></div>
            </div>
        </section>

        <section id="tasks-section" class="card">
            <h3>Available Tasks</h3>
            <div id="tasks-container">
                <!-- Tasks will be loaded here -->
            </div>
            <div class="completed-tasks-list">
                <h4>Completed Tasks</h4>
                <ul id="completed-tasks-container">
                    <!-- Completed tasks will be listed here -->
                </ul>
            </div>
        </section>

        <section id="spin-section" class="card">
            <h3>Spin the Wheel!</h3>
            <div class="spin-wheel-container">
                <div id="spinWheel">
                    <div class="spin-arrow"></div>
                    <!-- Segments will be generated by JS -->
                </div>
                <button class="btn waves-effect waves-light secondary-btn" id="spin-btn">Spin</button>
                <div id="spin-result" class="spin-result"></div>
            </div>
        </section>

        <section id="lucky-code-section" class="card">
            <h3>Enter Lucky Code</h3>
            <div class="input-field">
                <input id="enter-lucky-code" type="text" class="validate">
                <label for="enter-lucky-code">Lucky Code</label>
            </div>
            <button class="btn waves-effect waves-light" id="claim-lucky-code-btn">Claim</button>
            <p id="lucky-code-message" style="margin-top: 10px;"></p>
        </section>

        <section id="ads-section" class="card">
            <h3>Watch Ads for Points</h3>
            <p>Watch ads to earn points. Daily limit applies.</p>
            <div class="ad-placeholder" id="ad-container">
                Your ad will load here...
            </div>
            <button class="btn waves-effect waves-light secondary-btn" id="watch-ad-btn" disabled>Watch Ad (Daily Limit Reached)</button>
            <p id="ad-message" style="margin-top: 10px;"></p>
        </section>

        <section id="referral-section" class="card">
            <h3>Referral Program</h3>
            <div class="refer-link-card">
                <h4>Your Referral Link</h4>
                <input type="text" id="referral-link" readonly>
                <button class="btn waves-effect waves-light accent-btn" id="copy-referral-link-btn">Copy Link</button>
                <p>Share this link with friends to earn rewards!</p>
            </div>
            <div class="referral-stats" style="margin-top: 20px;">
                <h4>Your Referrals</h4>
                <p>Total Referrals: <span id="total-referrals">0</span></p>
                <p>Earned from Referrals: <span id="referral-earnings">0</span> <span class="point-unit">Points</span></p>
                <ul id="referral-list">
                    <!-- Referral list will be loaded here -->
                </ul>
            </div>
        </section>

        <section id="profile-section" class="card">
            <h3>Your Profile</h3>
            <div class="profile-details">
                <img id="profile-pic-edit" src="" alt="User Profile" class="profile-picture">
                <h4 id="profile-name-edit"></h4>
                <p>Telegram ID: <span id="profile-telegram-id-edit"></span></p>
            </div>
            <div class="withdraw-section">
                <h4>Withdrawal</h4>
                <p>100 Points ≈ 0.000078 TON (Rate can change)</p>
                <div class="withdraw-input">
                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/TON_logo.svg/1200px-TON_logo.svg.png" alt="TON Icon" class="ton-icon">
                    <input type="text" id="withdrawal-amount" placeholder="Enter amount in Points">
                </div>
                <div class="input-field">
                    <input id="ton-wallet-address" type="text" class="validate">
                    <label for="ton-wallet-address">Your TON Wallet Address</label>
                </div>
                <p>You will receive approximately: <strong id="estimated-ton">0.00000000 TON</strong></p>
                <button class="btn waves-effect waves-light secondary-btn" id="request-withdrawal-btn">Request Withdrawal</button>
                <p id="withdrawal-message" style="margin-top: 10px;"></p>
            </div>
            <div class="support-section" style="margin-top: 30px; text-align: center;">
                <h4>Need Support?</h4>
                <a href="https://t.me/pixelfrog_pxf" target="_blank" class="btn waves-effect waves-light accent-btn">Contact Support</a>
                <p style="margin-top: 10px;">Developer: <a href="https://t.me/Pixelfrogchat" target="_blank">@Pixelfrogchat</a></p>
            </div>
        </section>
    </div>

    <div class="bottom-nav">
        <div class="nav-item" data-section="home-section">
            <i class="material-icons">home</i>
            <span>Home</span>
        </div>
        <div class="nav-item" data-section="tasks-section">
            <i class="material-icons">list_alt</i>
            <span>Tasks</span>
        </div>
        <div class="nav-item" data-section="spin-section">
            <i class="material-icons">casino</i>
            <span>Spin</span>
        </div>
        <div class="nav-item" data-section="referral-section">
            <i class="material-icons">group_add</i>
            <span>Refer</span>
        </div>
        <div class="nav-item" data-section="profile-section">
            <i class="material-icons">account_circle</i>
            <span>Profile</span>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://unpkg.com/@tonconnect/ui@latest/dist/tonconnect-ui.min.js"></script>

    <script>
        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyA3SqCHzN3kLj7DC8Cyu9OzxPFtIlyyii4",
            authDomain: "maneybux-clone.firebaseapp.com",
            projectId: "maneybux-clone",
            storageBucket: "maneybux-clone.firebasestorage.app",
            messagingSenderId: "153207109623",
            appId: "1:153207109623:web:4cd48633c49c2ba3c1a0f2"
        };

        // Initialize Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const database = firebase.database();

        // --- Telegram Web App Initialization ---
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();

        let currentUser = {}; // To store current user data from Firebase
        let userReferrer = null; // To store who referred the user
        const TON_CONVERT_RATE = 0.000078 / 100; // Per 100 points

        // --- TON Connect Initialization ---
        // IMPORTANT: You need to host your tonconnect-manifest.json file on a public server.
        // Replace '<YOUR_APP_URL>' with your actual domain.
        const tonConnectUI = new TON_CONNECT_UI.TonConnectUI({
            manifestUrl: 'https://<YOUR_APP_URL>/tonconnect-manifest.json', // Replace with your manifest URL
            buttonRootId: 'ton-connect'
        });

        // Function to set the return URL for TWA
        tonConnectUI.uiOptions = {
            actionsConfiguration: {
                twaReturnUrl: `https://t.me/${tg.initDataUnsafe.user.username || 'YOUR_BOT_USERNAME'}`
            }
        };

        // --- Theme Toggle ---
        const themeToggle = document.getElementById('theme-toggle');
        const body = document.body;

        themeToggle.addEventListener('click', () => {
            body.classList.toggle('dark-theme');
            const isDark = body.classList.contains('dark-theme');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        });

        // Load theme from localStorage
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            body.classList.add('dark-theme');
        }

        // --- Sidenav Initialization ---
        document.addEventListener('DOMContentLoaded', function() {
            var elems = document.querySelectorAll('.sidenav');
            M.Sidenav.init(elems);
            // Initialize modals if any are used (none in this current template, but good practice)
            var modals = document.querySelectorAll('.modal');
            M.Modal.init(modals);
        });

        // --- Navigation Handling ---
        const navItems = document.querySelectorAll('.nav-item');
        const sections = document.querySelectorAll('section');

        navItems.forEach(item => {
            item.addEventListener('click', () => {
                // Remove active class from all nav items
                navItems.forEach(nav => nav.classList.remove('active'));
                // Add active class to clicked item
                item.classList.add('active');

                // Hide all sections
                sections.forEach(section => section.style.display = 'none');

                // Show the target section
                const targetSectionId = item.getAttribute('data-section');
                document.getElementById(targetSectionId).style.display = 'block';

                // Close sidenav
                M.Sidenav.getInstance(document.querySelector('.sidenav')).close();
            });
        });

        // Handle initial section load based on URL hash or default to home
        function loadSectionFromHash() {
            const hash = window.location.hash;
            if (hash) {
                const sectionId = hash.substring(1); // Remove '#'
                const targetSection = document.getElementById(sectionId);
                if (targetSection) {
                    sections.forEach(s => s.style.display = 'none');
                    targetSection.style.display = 'block';
                    // Activate corresponding nav item
                    navItems.forEach(nav => nav.classList.remove('active'));
                    const activeNavItem = document.querySelector(`.nav-item[data-section="${sectionId}"]`);
                    if (activeNavItem) activeNavItem.classList.add('active');
                    return;
                }
            }
            // Default to home section
            document.getElementById('home-section').style.display = 'block';
            document.querySelector('.nav-item[data-section="home-section"]').classList.add('active');
        }
        window.addEventListener('hashchange', loadSectionFromHash);
        loadSectionFromHash(); // Load on initial page load


        // --- User Data and Initialization ---
        async function initializeUser() {
            const telegramUserId = tg.initDataUnsafe.user.id;
            const telegramUsername = tg.initDataUnsafe.username || 'Guest';
            const telegramFirstName = tg.initDataUnsafe.user.first_name || 'User';
            const telegramLastName = tg.initDataUnsafe.user.last_name || '';
            const telegramProfilePic = tg.initDataUnsafe.user.photo_url;

            const userRef = database.ref(`users/${telegramUserId}`);

            userRef.once('value', async (snapshot) => {
                if (snapshot.exists()) {
                    // User exists
                    currentUser = snapshot.val();
                    console.log('Existing user:', currentUser);
                    // If the user has a referrer, but it's not stored in their profile, update it
                    if (userReferrer && !currentUser.referrer) {
                        currentUser.referrer = userReferrer;
                        await userRef.update({ referrer: userReferrer });
                        console.log(`Referrer ${userReferrer} assigned to user ${telegramUserId}`);
                    }
                } else {
                    // New user
                    console.log('New user detected.');
                    // Check for referrer from deep link
                    const urlParams = new URLSearchParams(window.location.search);
                    const referrerId = urlParams.get('ref'); // Assuming referrer ID is passed in URL

                    if (referrerId && referrerId != telegramUserId) { // Prevent self-referral
                        console.log('User referred by:', referrerId);
                        userReferrer = referrerId;
                        currentUser = {
                            id: telegramUserId,
                            username: telegramUsername,
                            firstName: telegramFirstName,
                            lastName: telegramLastName,
                            profilePic: telegramProfilePic,
                            balance: 0,
                            tasksCompleted: {},
                            referrals: {},
                            referrer: referrerId, // Store who referred them
                            createdAt: new Date().toISOString()
                        };
                        await userRef.set(currentUser);

                        // Add this user to the referrer's referral list
                        const referrerRef = database.ref(`users/${referrerId}/referrals/${telegramUserId}`);
                        referrerRef.set({
                            referredAt: new Date().toISOString()
                        });

                        // Grant referrer a bonus (e.g., 20% of initial balance, if applicable, or a fixed amount)
                        // For simplicity here, we'll add a small bonus when they are first referred
                        const referrerUserRef = database.ref(`users/${referrerId}`);
                        referrerUserRef.once('value', (referrerSnapshot) => {
                            if (referrerSnapshot.exists()) {
                                const referrerData = referrerSnapshot.val();
                                const referralBonus = 100; // Example: 100 points bonus
                                const newReferrerBalance = (referrerData.balance || 0) + referralBonus;
                                referrerUserRef.update({ balance: newReferrerBalance });
                                console.log(`Referral bonus ${referralBonus} granted to ${referrerId}`);
                                M.toast({ html: `You have earned a referral bonus!`, classes: 'rounded' });
                            }
                        });

                    } else {
                        // No referrer found or self-referral
                        currentUser = {
                            id: telegramUserId,
                            username: telegramUsername,
                            firstName: telegramFirstName,
                            lastName: telegramLastName,
                            profilePic: telegramProfilePic,
                            balance: 0,
                            tasksCompleted: {},
                            referrals: {},
                            createdAt: new Date().toISOString()
                        };
                        await userRef.set(currentUser);
                    }
                    console.log('New user created:', currentUser);
                }
                updateUI();
                setupRealtimeListeners();
            });
        }

        function updateUI() {
            document.getElementById('user-profile-pic').src = currentUser.profilePic || 'https://www.gravatar.com/avatar/?d=mp';
            document.getElementById('user-name').innerText = currentUser.firstName || 'User';
            document.getElementById('user-telegram-id').innerText = currentUser.id;

            document.getElementById('profile-pic-edit').src = currentUser.profilePic || 'https://www.gravatar.com/avatar/?d=mp';
            document.getElementById('profile-name-edit').innerText = currentUser.firstName || 'User';
            document.getElementById('profile-telegram-id-edit').innerText = currentUser.id;

            document.getElementById('user-balance').innerText = currentUser.balance !== undefined ? currentUser.balance.toLocaleString() : 0;

            // Update referral link
            const appUrl = tg.initDataUnsafe.bot.username ? `https://t.me/${tg.initDataUnsafe.bot.username}/app` : 'YOUR_BOT_LINK'; // Fallback to bot username
            const referralLink = `${appUrl}?ref=${currentUser.id}`;
            document.getElementById('referral-link').value = referralLink;

            // Update referral stats
            const referralCount = Object.keys(currentUser.referrals || {}).length;
            document.getElementById('total-referrals').innerText = referralCount.toLocaleString();

            // Calculate referral earnings (example: 20% of referred user's earnings - this is complex to track directly)
            // For simplicity, let's assume a fixed bonus for each referred user or a portion of tasks they complete.
            // A more robust system would require tracking completed tasks of referred users.
            // For now, we'll just display a placeholder and rely on referral bonuses.
            document.getElementById('referral-earnings').innerText = '0'; // Placeholder

            // Load referral list
            loadReferrals();

            // Load completed tasks
            loadCompletedTasks();

            // Set wallet address if available
            if (currentUser.tonWalletAddress) {
                document.getElementById('ton-wallet-address').value = currentUser.tonWalletAddress;
            }

            // Check daily check-in status
            checkDailyCheckInStatus();

            // Update spin wheel result if available
            if (currentUser.lastSpinResult) {
                document.getElementById('spin-result').innerText = `Last Spin: ${currentUser.lastSpinResult} Points`;
            }

            // Set Ads button state and message
            updateAdsButtonState();

            // Initialize TON Connect button if not already done
            if (!tonConnectUI.connectedWallet()) {
                // The button itself is rendered by the div with id="ton-connect"
            } else {
                document.getElementById('ton-connect').innerHTML = `Connected: ${tonConnectUI.connectedWallet().address.slice(0, 8)}...`;
            }
        }

        function setupRealtimeListeners() {
            const userRef = database.ref(`users/${currentUser.id}`);
            userRef.on('value', (snapshot) => {
                if (snapshot.exists()) {
                    currentUser = snapshot.val();
                    updateUI(); // Re-render UI when user data changes
                }
            });
        }

        // --- Task Loading and Interaction ---
        const tasksContainer = document.getElementById('tasks-container');
        const completedTasksContainer = document.getElementById('completed-tasks-container');

        function loadTasks() {
            const tasksRef = database.ref('tasks').orderByChild('createdAt');
            tasksRef.on('value', (snapshot) => {
                tasksContainer.innerHTML = ''; // Clear existing tasks
                snapshot.forEach((childSnapshot) => {
                    const task = childSnapshot.val();
                    // Check if user has already completed this task
                    if (currentUser.tasksCompleted && currentUser.tasksCompleted[task.id]) {
                        // Task is completed, do not show in available tasks
                        return;
                    }

                    const taskElement = document.createElement('div');
                    taskElement.className = 'task-item';
                    taskElement.innerHTML = `
                        <div>
                            <h3>${task.title}</h3>
                            <p>${task.description}</p>
                            <small>URL: <a href="${task.url}" target="_blank">${task.url}</a></small><br>
                            <small>Reward: <span class="task-reward">${task.rewardMin} - ${task.rewardMax}</span> Points</small>
                        </div>
                        <button class="btn waves-effect waves-light start-task-btn" data-task-id="${task.id}" data-task-url="${task.url}" data-reward-min="${task.rewardMin}" data-reward-max="${task.rewardMax}">
                            <i class="material-icons">play_arrow</i> Start
                        </button>
                    `;
                    tasksContainer.appendChild(taskElement);
                });
            });
        }

        tasksContainer.addEventListener('click', async (event) => {
            if (event.target.classList.contains('start-task-btn')) {
                const taskId = event.target.dataset.taskId;
                const taskUrl = event.target.dataset.taskUrl;
                const rewardMin = parseInt(event.target.dataset.rewardMin);
                const rewardMax = parseInt(event.target.dataset.rewardMax);

                // Check if user has reached impression limits for this task
                const taskImpressionLimit = currentUser.taskImpressions && currentUser.taskImpressions[taskId] ? currentUser.taskImpressions[taskId].count : 0;
                const taskImpressionMax = await getTaskImpressionMax(taskId); // Fetch max impressions for this task

                if (taskImpressionLimit >= taskImpressionMax) {
                    M.toast({ html: 'You have reached the impression limit for this task.', classes: 'rounded red' });
                    return;
                }


                // Open the task in a new tab or WebView (if in TWA)
                if (tg.isExpanded) {
                    // In Telegram Web App, open in a new tab for better isolation
                    window.open(taskUrl, '_blank');
                } else {
                    // In a regular browser, just open the URL
                    window.open(taskUrl, '_blank');
                }

                // Start timer and progress bar
                startTaskTimer(taskId, taskUrl, rewardMin, rewardMax);
            }
        });

        async function getTaskImpressionMax(taskId) {
            return new Promise((resolve, reject) => {
                database.ref(`tasks/${taskId}/impressionsMax`).once('value', (snapshot) => {
                    resolve(snapshot.val() || 5000); // Default to 5000 if not set
                }, reject);
            });
        }


        function startTaskTimer(taskId, taskUrl, rewardMin, rewardMax) {
            const taskRef = document.querySelector(`.start-task-btn[data-task-id="${taskId}"]`);
            if (!taskRef) return;

            taskRef.setAttribute('disabled', true); // Disable button
            taskRef.innerText = 'Processing...';

            let timer = 5; // 5 seconds verification time
            const timerElement = document.createElement('div');
            timerElement.className = 'timer';
            timerElement.innerText = `Verify in ${timer}...`;
            taskRef.parentNode.insertBefore(timerElement, taskRef); // Insert timer before the button

            const interval = setInterval(() => {
                timer--;
                timerElement.innerText = `Verify in ${timer}...`;
                if (timer <= 0) {
                    clearInterval(interval);
                    timerElement.remove();
                    verifyTaskCompletion(taskId, rewardMin, rewardMax);
                }
            }, 1000);
        }

        async function verifyTaskCompletion(taskId, rewardMin, rewardMax) {
            const taskBtn = document.querySelector(`.start-task-btn[data-task-id="${taskId}"]`);
            if (!taskBtn) return;

            // Increment impression count for this user and task
            const userTaskImpressionsRef = database.ref(`users/${currentUser.id}/taskImpressions/${taskId}`);
            const currentImpressions = await userTaskImpressionsRef.once('value').then(s => s.val() || { count: 0 });

            const newImpressionCount = currentImpressions.count + 1;
            await userTaskImpressionsRef.set({ count: newImpressionCount, lastView: new Date().toISOString() });
            console.log(`Task ${taskId} impression count: ${newImpressionCount}`);

            // Calculate reward
            const reward = Math.floor(Math.random() * (rewardMax - rewardMin + 1)) + rewardMin;

            // Update user balance
            const newBalance = (currentUser.balance || 0) + reward;
            await database.ref(`users/${currentUser.id}`).update({ balance: newBalance });

            // Mark task as completed for the user
            await database.ref(`users/${currentUser.id}/tasksCompleted/${taskId}`).set({
                completedAt: new Date().toISOString(),
                reward: reward,
                impressions: newImpressionCount
            });

            // Update UI
            M.toast({ html: `Task completed! You earned ${reward} points.`, classes: 'rounded green' });
            loadTasks(); // Reload available tasks
            updateUI(); // Update balance

            // Remove the completed task from the available list visually immediately
            const taskItem = taskBtn.closest('.task-item');
            if (taskItem) {
                taskItem.style.display = 'none';
            }

            // Add to completed tasks list
            const completedTaskRef = database.ref(`tasks/${taskId}`);
            completedTaskRef.once('value', (snapshot) => {
                const taskData = snapshot.val();
                const completedItem = document.createElement('li');
                completedItem.className = 'completed-task-item';
                completedItem.innerHTML = `
                    <strong>${taskData.title}</strong> - ${reward} Points (Impressions: ${newImpressionCount})
                `;
                completedTasksContainer.appendChild(completedItem);
            });
        }

        function loadCompletedTasks() {
            completedTasksContainer.innerHTML = ''; // Clear existing
            if (currentUser.tasksCompleted) {
                Object.entries(currentUser.tasksCompleted).forEach(([taskId, completionData]) => {
                    const completedItem = document.createElement('li');
                    completedItem.className = 'completed-task-item';
                    completedItem.innerHTML = `
                        <strong>Task ID: ${taskId}</strong> - ${completionData.reward} Points (Completed: ${new Date(completionData.completedAt).toLocaleDateString()})
                    `;
                    completedTasksContainer.appendChild(completedItem);
                });
            }
        }

        // --- Lucky Code Handling ---
        const enterLuckyCodeInput = document.getElementById('enter-lucky-code');
        const claimLuckyCodeBtn = document.getElementById('claim-lucky-code-btn');
        const luckyCodeMessage = document.getElementById('lucky-code-message');

        claimLuckyCodeBtn.addEventListener('click', () => {
            const code = enterLuckyCodeInput.value.trim().toUpperCase();
            if (!code) {
                luckyCodeMessage.innerText = 'Please enter a lucky code.';
                luckyCodeMessage.style.color = 'red';
                return;
            }

            const luckyCodeRef = database.ref(`luckyCodes/${code}`);
            luckyCodeRef.once('value', (snapshot) => {
                if (snapshot.exists()) {
                    const codeData = snapshot.val();
                    const rewardMin = codeData.rewardMin;
                    const rewardMax = codeData.rewardMax;
                    const reward = Math.floor(Math.random() * (rewardMax - rewardMin + 1)) + rewardMin;

                    // Check if user has already claimed this code
                    if (currentUser.claimedLuckyCodes && currentUser.claimedLuckyCodes[code]) {
                        luckyCodeMessage.innerText = 'You have already claimed this code.';
                        luckyCodeMessage.style.color = 'orange';
                        return;
                    }

                    const newBalance = (currentUser.balance || 0) + reward;
                    database.ref(`users/${currentUser.id}`).update({ balance: newBalance });

                    // Mark code as claimed
                    database.ref(`users/${currentUser.id}/claimedLuckyCodes/${code}`).set({
                        claimedAt: new Date().toISOString(),
                        reward: reward
                    });

                    luckyCodeMessage.innerText = `Success! You received ${reward} points.`;
                    luckyCodeMessage.style.color = 'green';
                    enterLuckyCodeInput.value = ''; // Clear input
                    updateUI();
                } else {
                    luckyCodeMessage.innerText = 'Invalid lucky code.';
                    luckyCodeMessage.style.color = 'red';
                }
            });
        });

        // --- Spin Wheel Logic ---
        const spinWheel = document.getElementById('spinWheel');
        const spinBtn = document.getElementById('spin-btn');
        const spinResult = document.getElementById('spin-result');
        const spinSegments = [
            { value: 50, color: '#FFCDD2' }, // Light Red
            { value: 100, color: '#C8E6C9' }, // Light Green
            { value: 150, color: '#BBDEFB' }, // Light Blue
            { value: 200, color: '#FFF9C4' }, // Light Yellow
            { value: 300, color: '#D1C4E9' }, // Light Purple
            { value: 75, color: '#F8BBD0' },  // Light Pink
            { value: 120, color: '#B2EBF2' }, // Light Cyan
            { value: 250, color: '#E1BEE7' }  // Light Deep Purple
        ];
        const SEGMENT_COUNT = spinSegments.length;
        const ROTATION_PER_SEGMENT = 360 / SEGMENT_COUNT;

        function createSpinWheel() {
            spinWheel.innerHTML = '<div class="spin-arrow"></div>'; // Reset
            spinSegments.forEach((segment, index) => {
                const segmentElement = document.createElement('div');
                segmentElement.className = 'spin-segment';
                segmentElement.style.backgroundColor = segment.color;
                segmentElement.style.transform = `rotate(${index * ROTATION_PER_SEGMENT}deg) skewY(${90 - ROTATION_PER_SEGMENT}deg)`;
                segmentElement.style.setProperty('--skew-angle', `${90 - ROTATION_PER_SEGMENT}deg`);
                segmentElement.innerHTML = `
                    <span style="transform: skewY(${ROTATION_PER_SEGMENT - 90}deg) rotate(${ROTATION_PER_SEGMENT / 2}deg);">${segment.value} pts</span>
                `;
                spinWheel.appendChild(segmentElement);
            });
        }
        createSpinWheel();

        spinBtn.addEventListener('click', async () => {
            // Check if user has enough points to spin (optional, or just grant a free spin)
            if (!currentUser.freeSpins || currentUser.freeSpins <= 0) {
                // Here you could implement a cost for spinning
                M.toast({ html: 'You have run out of free spins!', classes: 'rounded orange' });
                return;
            }

            spinBtn.disabled = true;
            spinResult.innerText = '';
            spinWheel.classList.add('spinning');

            // Determine a winning segment
            const randomIndex = Math.floor(Math.random() * SEGMENT_COUNT);
            const winningSegment = spinSegments[randomIndex];
            const winningRotation = randomIndex * ROTATION_PER_SEGMENT;

            // Calculate the final rotation to land on the winning segment
            // We add some extra random degrees to make it look more dynamic
            const extraRandomDegrees = Math.floor(Math.random() * (ROTATION_PER_SEGMENT * 0.8));
            const finalRotation = (360 * 10) - winningRotation - extraRandomDegrees; // Spin 10 times + landing

            spinWheel.style.transform = `rotate(${finalRotation}deg)`;

            // Wait for animation to almost finish
            setTimeout(async () => {
                spinWheel.classList.remove('spinning');
                spinWheel.style.transform = `rotate(${finalRotation % 360}deg)`; // Set to final position

                const reward = winningSegment.value;
                const newBalance = (currentUser.balance || 0) + reward;
                await database.ref(`users/${currentUser.id}`).update({ balance: newBalance });
                await database.ref(`users/${currentUser.id}/freeSpins`).set((currentUser.freeSpins || 1) - 1); // Decrement free spins
                await database.ref(`users/${currentUser.id}/lastSpinResult`).set(`${reward} Points`);

                spinResult.innerText = `You won ${reward} Points!`;
                spinBtn.disabled = false;
                updateUI(); // Update balance and free spin count
            }, 5000); // Match the animation duration
        });

        // --- Ads Section ---
        const watchAdBtn = document.getElementById('watch-ad-btn');
        const adContainer = document.getElementById('ad-container');
        const adMessage = document.getElementById('ad-message');
        const ADS_REWARD_POINTS = 10; // Points per ad
        const ADS_DAILY_LIMIT = 50; // Max ads per day
        const AD_SDK_LOAD_DELAY = 2000; // Delay before trying to load ad SDK

        // Load ad SDK dynamically and handle its loading
        function loadAdSDK() {
            const script = document.createElement('script');
            script.src = '//libtl.com/sdk.js';
            script.setAttribute('data-zone', '9809601'); // Your ad zone ID
            script.setAttribute('data-sdk', 'show_9809601');
            script.async = true;

            script.onload = () => {
                console.log('Ad SDK loaded.');
                // Now that SDK is loaded, update button state
                updateAdsButtonState();
            };
            script.onerror = () => {
                console.error('Failed to load Ad SDK.');
                adContainer.innerHTML = 'Ad loading failed. Please try again later.';
                watchAdBtn.disabled = true; // Disable if SDK fails to load
            };
            document.body.appendChild(script);
        }

        function updateAdsButtonState() {
            const now = new Date();
            const today = now.toDateString();
            const lastAdViewDate = currentUser.lastAdViewDate;
            const adViewsToday = currentUser.adViewsToday || 0;

            let canWatchAd = true;
            let message = '';

            if (lastAdViewDate && new Date(lastAdViewDate).toDateString() === today) {
                if (adViewsToday >= ADS_DAILY_LIMIT) {
                    canWatchAd = false;
                    message = `Daily ad limit (${ADS_DAILY_LIMIT}) reached. Try again tomorrow.`;
                } else {
                    message = `Watch Ad (${adViewsToday + 1}/${ADS_DAILY_LIMIT})`;
                }
            } else {
                // New day or first ad view
                message = `Watch Ad (1/${ADS_DAILY_LIMIT})`;
                // Reset daily count if it's a new day
                if (lastAdViewDate && new Date(lastAdViewDate).toDateString() !== today) {
                    database.ref(`users/${currentUser.id}`).update({ adViewsToday: 0 });
                }
            }

            watchAdBtn.innerText = message;
            watchAdBtn.disabled = !canWatchAd;
            adMessage.innerText = message.startsWith('Watch') ? '' : message; // Show message if limit reached
            adMessage.style.color = !canWatchAd ? 'red' : 'green';
        }

        watchAdBtn.addEventListener('click', () => {
            if (typeof show_9809601 === 'function') {
                const now = new Date();
                const today = now.toDateString();
                const adViewsToday = (currentUser.adViewsToday || 0);

                watchAdBtn.disabled = true; // Disable while ad is showing
                adContainer.innerHTML = 'Loading ad...'; // Placeholder

                show_9809601().then(async () => {
                    // User has watched the ad successfully
                    const reward = ADS_REWARD_POINTS;
                    const newBalance = (currentUser.balance || 0) + reward;
                    const newAdViewsToday = adViewsToday + 1;

                    await database.ref(`users/${currentUser.id}`).update({
                        balance: newBalance,
                        adViewsToday: newAdViewsToday,
                        lastAdViewDate: new Date().toISOString()
                    });

                    adContainer.innerHTML = 'Ad viewed successfully!';
                    M.toast({ html: `Ad watched! You earned ${reward} points.`, classes: 'rounded green' });
                    updateAdsButtonState(); // Update button to next state
                    updateUI();
                }).catch((error) => {
                    console.error('Ad display failed:', error);
                    adContainer.innerHTML = 'Could not load ad. Please try again.';
                    adMessage.innerText = 'Ad failed to load.';
                    adMessage.style.color = 'red';
                    watchAdBtn.disabled = false; // Re-enable if ad fails
                    updateAdsButtonState(); // Re-evaluate button state
                });
            } else {
                console.error('Ad SDK (show_9809601) is not available.');
                adContainer.innerHTML = 'Ad service is unavailable.';
                watchAdBtn.disabled = true;
            }
        });


        // --- Referral Logic ---
        const referralLinkInput = document.getElementById('referral-link');
        const copyReferralLinkBtn = document.getElementById('copy-referral-link-btn');

        copyReferralLinkBtn.addEventListener('click', () => {
            referralLinkInput.select();
            document.execCommand('copy');
            M.toast({ html: 'Referral link copied!', classes: 'rounded' });
        });

        function loadReferrals() {
            const referralList = document.getElementById('referral-list');
            referralList.innerHTML = ''; // Clear existing
            if (currentUser.referrals) {
                Object.entries(currentUser.referrals).forEach(([referredUserId, referralData]) => {
                    const listItem = document.createElement('li');
                    listItem.className = 'referral-list-item';
                    // Fetch referred user's basic info if available in Firebase
                    // For simplicity here, just showing ID and date
                    listItem.innerHTML = `
                        Referral ID: <span style="font-weight: bold;">${referredUserId}</span> (Referred on: ${new Date(referralData.referredAt).toLocaleDateString()})
                    `;
                    referralList.appendChild(listItem);
                });
            }
            if (referralList.children.length === 0) {
                referralList.innerHTML = '<li>No referrals yet.</li>';
            }
        }

        // --- Profile and Withdrawal ---
        const withdrawalAmountInput = document.getElementById('withdrawal-amount');
        const tonWalletAddressInput = document.getElementById('ton-wallet-address');
        const estimatedTonDisplay = document.getElementById('estimated-ton');
        const requestWithdrawalBtn = document.getElementById('request-withdrawal-btn');
        const withdrawalMessage = document.getElementById('withdrawal-message');

        withdrawalAmountInput.addEventListener('input', updateEstimatedTon);
        tonWalletAddressInput.addEventListener('input', () => {
            // Save wallet address to user profile on input
            const walletAddress = tonWalletAddressInput.value.trim();
            if (walletAddress.startsWith('0:') && walletAddress.length === 51) { // Basic TON address validation
                database.ref(`users/${currentUser.id}`).update({ tonWalletAddress: walletAddress });
            }
            updateEstimatedTon(); // Update estimation too
        });

        function updateEstimatedTon() {
            const amountInPoints = parseInt(withdrawalAmountInput.value);
            if (!isNaN(amountInPoints) && amountInPoints >= 100) { // Minimum withdrawal points
                const estimatedTon = (amountInPoints * TON_CONVERT_RATE).toFixed(9); // Display with more precision
                estimatedTonDisplay.innerText = `${estimatedTon} TON`;
            } else {
                estimatedTonDisplay.innerText = '0.000000000 TON';
            }
        }

        requestWithdrawalBtn.addEventListener('click', async () => {
            const amountInPoints = parseInt(withdrawalAmountInput.value);
            const walletAddress = tonWalletAddressInput.value.trim();

            if (isNaN(amountInPoints) || amountInPoints < 100) {
                withdrawalMessage.innerText = 'Minimum withdrawal is 100 points.';
                withdrawalMessage.style.color = 'red';
                return;
            }
            if (!walletAddress.startsWith('0:') || walletAddress.length !== 51) {
                withdrawalMessage.innerText = 'Please enter a valid TON wallet address.';
                withdrawalMessage.style.color = 'red';
                return;
            }
            if ((currentUser.balance || 0) < amountInPoints) {
                withdrawalMessage.innerText = 'Insufficient balance.';
                withdrawalMessage.style.color = 'red';
                return;
            }

            // Save wallet address to user profile
            await database.ref(`users/${currentUser.id}`).update({ tonWalletAddress: walletAddress });

            const estimatedTon = (amountInPoints * TON_CONVERT_RATE).toFixed(9);

            // Use TON Connect to send transaction
            try {
                await tonConnectUI.sendTransaction({
                    validUntil: Math.floor(Date.now() / 1000) + 600, // 10 minutes
                    messages: [
                        {
                            address: walletAddress, // User's wallet address for direct withdrawal (or your bot's address for manual payout)
                            amount: (amountInPoints * 1e9 * TON_CONVERT_RATE).toString(), // Convert points to TON and then to nanoton
                            // NOTE: This amount calculation needs careful verification.
                            // It's better to send a fixed amount from your bot's wallet for payout
                            // For direct user-to-user, this might be problematic.
                            // A more common approach is: user requests withdrawal -> admin reviews -> admin sends from bot.
                            // For this example, we'll simulate a request and rely on admin for payout.
                        }
                    ]
                });

                // If transaction is successfully initiated (not necessarily completed on-chain)
                const withdrawalRef = database.ref('withdrawals').push();
                withdrawalRef.set({
                    userId: currentUser.id,
                    userName: currentUser.firstName,
                    amountPoints: amountInPoints,
                    estimatedTon: estimatedTon,
                    tonWalletAddress: walletAddress,
                    status: 'pending', // pending, approved, rejected, sent
                    requestedAt: new Date().toISOString(),
                    isTONConnectWithdrawal: true, // Mark as initiated via TON Connect
                    transactionHash: 'initiated' // Placeholder for actual hash if available
                });

                // Deduct points from user balance (or do this after admin approval)
                const newBalance = (currentUser.balance || 0) - amountInPoints;
                await database.ref(`users/${currentUser.id}`).update({ balance: newBalance });

                withdrawalMessage.innerText = `Withdrawal request submitted for ${estimatedTon} TON. Check history for status.`;
                withdrawalMessage.style.color = 'green';
                withdrawalAmountInput.value = '';
                updateEstimatedTon();
                updateUI(); // Update balance

            } catch (error) {
                console.error('TON Transaction Error:', error);
                withdrawalMessage.innerText = `Withdrawal failed: ${error.message || 'Unknown error'}`;
                withdrawalMessage.style.color = 'red';
            }
        });

        // --- Daily Check-in ---
        const dailyCheckInBtn = document.getElementById('daily-check-in-btn');
        const dailyCheckInMessage = document.getElementById('daily-check-in-message');
        const DAILY_REWARD_POINTS = 50;

        function checkDailyCheckInStatus() {
            const lastCheckIn = currentUser.lastDailyCheckIn;
            const now = new Date();
            const today = now.toDateString();

            if (lastCheckIn && new Date(lastCheckIn).toDateString() === today) {
                dailyCheckInBtn.innerText = 'Already Checked In';
                dailyCheckInBtn.disabled = true;
                dailyCheckInMessage.style.display = 'block';
                dailyCheckInMessage.innerText = 'You have already checked in today!';
            } else {
                dailyCheckInBtn.innerText = 'Claim Reward';
                dailyCheckInBtn.disabled = false;
                dailyCheckInMessage.style.display = 'none';
            }
        }

        dailyCheckInBtn.addEventListener('click', async () => {
            dailyCheckInBtn.disabled = true;
            dailyCheckInMessage.style.display = 'block';

            const newBalance = (currentUser.balance || 0) + DAILY_REWARD_POINTS;
            await database.ref(`users/${currentUser.id}`).update({
                balance: newBalance,
                lastDailyCheckIn: new Date().toISOString()
            });

            dailyCheckInMessage.innerText = `You received ${DAILY_REWARD_POINTS} points!`;
            dailyCheckInMessage.style.color = 'green';
            checkDailyCheckInStatus(); // Update button state
            updateUI(); // Update balance
        });

        // --- Logout ---
        const logoutLink = document.querySelector('a[href="#logout"]');
        logoutLink.addEventListener('click', () => {
            // In a real app, you'd clear session tokens/cookies and redirect.
            // For Telegram Web Apps, often you don't need explicit logout,
            // as closing the web app is sufficient.
            // If you have custom auth, implement it here.
            alert("Logout functionality is a placeholder.");
            // Example: window.location.href = '/login.html';
        });

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Dynamically load ad SDK after a short delay
            setTimeout(loadAdSDK, AD_SDK_LOAD_DELAY);

            // Initialize Telegram user info
            if (tg.initDataUnsafe && tg.initDataUnsafe.user) {
                // Get referrer from URL if it exists before initializing user
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('ref')) {
                    userReferrer = urlParams.get('ref');
                }
                await initializeUser();
                loadTasks(); // Load tasks after user is initialized
                updateEstimatedTon(); // Initial calculation
            } else {
                alert("Please open this app from Telegram.");
                document.body.innerHTML = '<h3 style="text-align: center; color: red;">Please open this app within Telegram.</h3>';
            }
        });

    </script>
</body>
</html>
